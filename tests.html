<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Proposal Builder Tests</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 2rem; }
    .test-suite { margin-bottom: 2rem; border: 1px solid #ddd; padding: 1rem; }
    .test-case { margin: 0.5rem 0; padding: 0.5rem; }
    .test-pass { background: #d4edda; color: #155724; }
    .test-fail { background: #f8d7da; color: #721c24; }
    .test-skip { background: #ffeaa7; color: #856404; }
    pre { background: #f8f9fa; padding: 0.5rem; overflow-x: auto; }
  </style>
</head>
<body>
  <h1>Proposal Builder Test Suite</h1>
  <p>This tests critical functionality of the proposal builder application.</p>
  <div id="test-results">Loading tests...</div>

  <script>
    // Simple test framework
    class TestRunner {
      constructor() {
        this.results = [];
        this.currentSuite = null;
      }

      suite(name, fn) {
        this.currentSuite = { name, tests: [] };
        try {
          fn.call(this);
          this.results.push(this.currentSuite);
        } catch (error) {
          this.currentSuite.tests.push({ name: 'Suite Setup', status: 'fail', error: error.message });
          this.results.push(this.currentSuite);
        }
        this.currentSuite = null;
      }

      test(name, fn) {
        try {
          fn.call(this);
          this.currentSuite.tests.push({ name, status: 'pass', error: null });
        } catch (error) {
          this.currentSuite.tests.push({ name, status: 'fail', error: error.message });
        }
      }

      assert(condition, message) {
        if (!condition) {
          throw new Error(message || 'Assertion failed');
        }
      }

      assertEqual(actual, expected, message) {
        if (actual !== expected) {
          throw new Error(message || 'Expected ' + expected + ', got ' + actual);
        }
      }

      assertNotNull(value, message) {
        if (value === null || value === undefined) {
          throw new Error(message || 'Value should not be null');
        }
      }

      render() {
        const container = document.getElementById('test-results');
        let html = '';

        for (const suite of this.results) {
          const passed = suite.tests.filter(t => t.status === 'pass').length;
          const failed = suite.tests.filter(t => t.status === 'fail').length;
          
          html += '<div class="test-suite">';
          html += '<h2>' + suite.name + ' (' + passed + ' passed, ' + failed + ' failed)</h2>';
          
          for (const test of suite.tests) {
            html += '<div class="test-case test-' + test.status + '">';
            html += '<strong>' + test.name + '</strong>';
            if (test.error) {
              html += '<pre>Error: ' + test.error + '</pre>';
            }
            html += '</div>';
          }
          
          html += '</div>';
        }

        container.innerHTML = html;
      }
    }

    // Basic utility tests (without external dependencies)
    const runner = new TestRunner();

    runner.suite('Basic Functionality Tests', function() {
      this.test('Test framework is working', function() {
        this.assert(true, 'Basic assertion should pass');
        this.assertEqual(1, 1, 'Basic equality should work');
      });

      this.test('HTML escaping function exists and works', function() {
        // We'll test by directly including the escapeHtml function
        const escapeHtml = (str) => {
          if (!str) return '';
          return String(str)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#x27;')
            .replace(/`/g, '&#x60;');
        };

        this.assertEqual(escapeHtml(''), '');
        this.assertEqual(escapeHtml('Normal text'), 'Normal text');
        this.assert(escapeHtml('<script>').includes('&lt;'), 'Should escape less-than');
        this.assert(escapeHtml('<script>').includes('&gt;'), 'Should escape greater-than');
      });

      this.test('Safe filename function exists and works', function() {
        const safe = (s) => (s || "Client").replace(/[^a-z0-9_\-]+/gi, "_").slice(0,120);
        
        this.assertEqual(safe('Test Client'), 'Test_Client');
        this.assertEqual(safe(''), 'Client');
        this.assert(safe('Client/Name<>:|').indexOf('/') === -1, 'Should remove invalid characters');
      });

      this.test('QR Code generation function exists', function() {
        // Test that canvas API is available for QR generation
        const canvas = document.createElement('canvas');
        this.assertNotNull(canvas.getContext, 'Canvas API should be available');
        
        const ctx = canvas.getContext('2d');
        this.assertNotNull(ctx, 'Canvas 2D context should be available');
        
        // Test that we can create a data URL
        canvas.width = 100;
        canvas.height = 100;
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, 50, 50);
        
        const dataUrl = canvas.toDataURL();
        this.assert(dataUrl.startsWith('data:image/png;base64,'), 'Should generate PNG data URL');
      });
    });

    runner.suite('Browser Compatibility', function() {
      this.test('Required browser APIs are available', function() {
        this.assertNotNull(window.localStorage, 'localStorage should be available');
        this.assertNotNull(window.fetch || window.XMLHttpRequest, 'HTTP request capability should be available');
        this.assertNotNull(document.createElement, 'DOM manipulation should be available');
        this.assertNotNull(window.URL, 'URL API should be available');
        this.assertNotNull(window.Blob, 'Blob API should be available');
      });

      this.test('File download APIs are available', function() {
        this.assertNotNull(window.URL.createObjectURL, 'createObjectURL should be available');
        this.assertNotNull(window.URL.revokeObjectURL, 'revokeObjectURL should be available');
        
        // Test blob creation
        const blob = new Blob(['test'], { type: 'text/plain' });
        this.assertNotNull(blob, 'Blob creation should work');
      });
    });

    runner.suite('Data Validation', function() {
      this.test('Form data structure validation', function() {
        const mockFormData = {
          clientName: 'Test Client',
          projectName: 'Test Project',
          price: '25000'
        };
        
        this.assertNotNull(mockFormData.clientName, 'Client name should exist');
        this.assertNotNull(mockFormData.projectName, 'Project name should exist');
        this.assert(/^\d+$/.test(mockFormData.price), 'Price should be numeric');
      });
    });

    runner.suite('Admin Logo Variant Assignment', function() {
      this.test('Config save/load with logo variants', function() {
        const LS_KEY = 'foundry-admin-config-test';
        
        // Simulate saving config with logo variants
        const testConfig = {
          version: 1,
          company: {
            name: 'Test Company',
            logoAssetIdDark: 'dark-asset-123',
            logoAssetIdLight: 'light-asset-456'
          },
          branding: {
            showLogoInPrint: true
          }
        };
        
        localStorage.setItem(LS_KEY, JSON.stringify(testConfig));
        
        // Simulate loading config
        const loadedRaw = localStorage.getItem(LS_KEY);
        const loaded = JSON.parse(loadedRaw);
        
        this.assertEqual(loaded.company.logoAssetIdDark, 'dark-asset-123', 'Dark logo variant should persist');
        this.assertEqual(loaded.company.logoAssetIdLight, 'light-asset-456', 'Light logo variant should persist');
        this.assert(loaded.branding.showLogoInPrint === true, 'Show logo in print should be enabled');
        
        // Cleanup
        localStorage.removeItem(LS_KEY);
      });

      this.test('Active logo selection logic', function() {
        // Simulate the logic from setDefaultLogoVariant
        const mockImages = {};
        
        // Scenario 1: Only dark logo set
        mockImages.logoOnDark = 'data:image/png;base64,dark123';
        mockImages.logoOnLight = null;
        
        if (mockImages.logoOnDark) {
          mockImages.logo = mockImages.logoOnDark;
        } else if (mockImages.logoOnLight) {
          mockImages.logo = mockImages.logoOnLight;
        }
        
        this.assertEqual(mockImages.logo, 'data:image/png;base64,dark123', 'Active logo should be dark when only dark is set');
        
        // Scenario 2: Both dark and light logos set (dark should take precedence)
        mockImages.logoOnDark = 'data:image/png;base64,dark123';
        mockImages.logoOnLight = 'data:image/png;base64,light456';
        
        if (mockImages.logoOnDark) {
          mockImages.logo = mockImages.logoOnDark;
        } else if (mockImages.logoOnLight) {
          mockImages.logo = mockImages.logoOnLight;
        }
        
        this.assertEqual(mockImages.logo, 'data:image/png;base64,dark123', 'Active logo should be dark when both are set');
        
        // Scenario 3: Only light logo set
        mockImages.logoOnDark = null;
        mockImages.logoOnLight = 'data:image/png;base64,light456';
        
        if (mockImages.logoOnDark) {
          mockImages.logo = mockImages.logoOnDark;
        } else if (mockImages.logoOnLight) {
          mockImages.logo = mockImages.logoOnLight;
        }
        
        this.assertEqual(mockImages.logo, 'data:image/png;base64,light456', 'Active logo should be light when only light is set');
      });

      this.test('Deep merge preserves logo variant IDs', function() {
        // Replicate the deepMerge function
        const deepMerge = (base, override) => {
          if (Array.isArray(base)) return override ?? base;
          if (typeof base === 'object' && base) {
            const out = { ...base };
            for (const k of Object.keys(override || {})) {
              out[k] = deepMerge(base[k], override[k]);
            }
            return out;
          }
          return override ?? base;
        };
        
        const defaultConfig = {
          company: {
            logoAssetIdDark: '',
            logoAssetIdLight: ''
          }
        };
        
        const savedConfig = {
          company: {
            logoAssetIdDark: 'dark-123',
            logoAssetIdLight: 'light-456'
          }
        };
        
        const merged = deepMerge(defaultConfig, savedConfig);
        
        this.assertEqual(merged.company.logoAssetIdDark, 'dark-123', 'Dark variant should be preserved in merge');
        this.assertEqual(merged.company.logoAssetIdLight, 'light-456', 'Light variant should be preserved in merge');
      });
    });

    // Run the tests
    runner.render();
  </script>
</body>
</html>